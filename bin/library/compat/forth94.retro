( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( 1994 ANS FORTH                                            )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( This is an attempt to provide a large subset of the 1994  )
( ANS FORTH standard words in Retro.                        )
(                                                           )
( Note:                                                     )
(   It is unlikely that I will ever fully support ANS FORTH )
(   in Retro, unless someone else steps up to complete the  )
(   missing bits. [this has happened before, during the 9.x )
(   days; but the current codebase for Retro is all new and )
(   no longer compatible with some of the low-level tricks  )
(   used back then.]                                        )
(                                                           )
( Stuff to keep in mind:                                    )
(   -  All words provided by this layer are UPPERCASE. As   )
(      per 3.4.2 this is all that is strictly required and  )
(      it lets us avoid many namespace collisions with the  )
(      core Retro language.                                 )
(   -  This has received little testing and bugs are likely )
(      to exist.                                            )
(   -  At present, work is only being done [albeit, slowly] )
(      on the CORE and CORE EXT wordset.                    )
(   -  Non-implemented functionality is stubbed out.        )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )

: array for 0 , next ;
create holdaddr 66 array
create hld 0 ,

: .unsupported drop ." Word unsupported" cr ;
: stub: create ['] .unsupported last @ d->class ! ;

( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( 6.1 CORE                                                  )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( 6.1.1710 IMMEDIATE )        : IMMEDIATE ['] .macro last @ d->class ! ;

( 6.1.0010 !         )        ( Supported by RETRO )
( 6.1.0030 #         )        ( --- )
                              stub: #
( 6.1.0040 #>        )        : #> 2drop hld @ holdaddr over - swap ;
( 6.1.0050 #S        )        ( --- )
                              stub: #S
( 6.1.0070 '         )        ( Supported by RETRO )
( 6.1.0080 (         )        ( Supported by RETRO )
( 6.1.0090 *         )        ( Supported by RETRO )
( 6.1.0100 */        )        : */ push * pop / ;
( 6.1.0110 */MOD     )        : */MOD push * pop /mod ;
( 6.1.0120 +         )        ( Supported by RETRO )
( 6.1.0130 +!        )        ( Supported by RETRO )
( 6.1.0140 +LOOP     )        ( --- )
                              stub: +LOOP
( 6.1.0150 ,         )        ( Supported by RETRO )
( 6.1.0160 -         )        ( Supported by RETRO )
( 6.1.0180 .         )        ( --- )
( 6.1.0190 ."        )        : ." ['] s" execute ['] type compile ; IMMEDIATE
( 6.1.0230 /         )        ( Supported by RETRO )
( 6.1.0240 /MOD      )        : /MOD /mod ;
( 6.1.0250 0<        )        : 0< 0 <if -1 ;; then 0 ;
( 6.1.0270 0=        )        : 0= 0 =if -1 ;; then 0 ;
( 6.1.0290 1+        )        ( Supported by RETRO )
( 6.1.0300 1-        )        ( Supported by RETRO )
( 6.1.0310 2!        )        : 2! tuck ! 1+ ! ;
( 6.1.0320 2*        )        : 2* 1 << ;
( 6.1.0330 2/        )        : 2/ dup 1  >> swap -1 >> not and or ;
( 6.1.0350 2@        )        : 2@ dup 1+ @ swap @ ;
( 6.1.0370 2DROP     )        : 2DROP 2drop ;
( 6.1.0380 2DUP      )        : 2DUP 2dup ;
( 6.1.0400 2OVER     )        : 2OVER push push 2dup pop -rot pop -rot ;
( 6.1.0430 2SWAP     )        : 2SWAP rot push rot pop ;
                              variable latest
( 6.1.0450 :         )        here is : ] create last @ latest ! latest @ @ last ! ] ;
( 6.1.0460 ;         )        here is ; ] latest @ last ! ['] ;; execute ['] [ execute ['] .word last @ d->class ! ;; [
( 6.1.0480 <         )        : < <if -1 ;; then 0 ;
( 6.1.0490 <#        )        : <# 0 hld ! ;
( 6.1.0530 =         )        : = =if -1 ;; then 0 ;
( 6.1.0540 >         )        : > >if -1 ;; then 0 ;
( 6.1.0550 >BODY     )        : >BODY ;
( 6.1.0560 >IN       )        ( --- )
                              stub: >IN
( 6.1.0570 >NUMBER   )        ( --- )
                              stub: >NUMBER
( 6.1.0580 >R        )        : >R 5 , ; IMMEDIATE
( 6.1.0630 ?DUP      )        : ?DUP dup 0; ;
( 6.1.0650 @         )        ( Supported by RETRO )
                              : drop-stack depth 0; for drop next ;
( 6.1.0670 ABORT     )        : ABORT  drop-stack 0 execute ;
( 6.1.0680 ABORT"    )        : ABORT" 0 literal, ['] !if execute ['] ." execute ['] ABORT compile ['] then execute ; IMMEDIATE
( 6.1.0690 ABS       )        : ABS dup 0 <if -1 * then ;
( 6.1.0695 ACCEPT    )        ( --- )
                              stub: ACCEPT
( 6.1.0705 ALIGN     )        : ALIGN ;
( 6.1.0706 ALIGNED   )        : ALIGNED ;
                              : heap ['] here 3 + @ ;
( 6.1.0710 ALLOT     )        : ALLOT heap @ + heap ! ;
( 6.1.0720 AND       )        : AND and ;
( 6.1.0750 BASE      )        create BASE 10 ,
( 6.1.0760 BEGIN     )        : BEGIN ` repeat ; IMMEDIATE
( 6.1.0770 BL        )        : BL 32 ;
( 6.1.0850 C!        )        : C! ! ;
( 6.1.0860 C,        )        : C, , ;
( 6.1.0870 C@        )        : C@ @ ;
( 6.1.0880 CELL+     )        : CELL+ 1+ ;
( 6.1.0890 CELLS     )        : CELLS ;
( 6.1.0895 CHAR      )        : CHAR 32 accept tib @ ;
( 6.1.0897 CHAR+     )        : CHAR+ 1+ ;
( 6.1.0898 CHARS     )        : CHARS ;
( 6.1.0950 CONSTANT  )        : CONSTANT create last @ d->xt ! ;
( 6.1.0980 COUNT     )        : COUNT dup @ swap 1+ swap ;
( 6.1.0990 CR        )        : CR cr ;
( 6.1.1000 CREATE    )        : CREATE create ;
( 6.1.1170 DECIMAL   )        : DECIMAL 10 BASE ! ;
( 6.1.1200 DEPTH     )        : DEPTH depth ;
( 6.1.1240 DO        )        ( --- )
                              stub: DO
                              : reclass last @ d->class ! ;
                              : .does compiler @ -1 =if swap literal, compile pop drop ;; then drop ;
( 6.1.1250 DOES>     )        : DOES> 1 , here 0 , ['] reclass compile ['] ;; execute here swap ! here literal, ['] .does compile ; IMMEDIATE
( 6.1.1260 DROP      )        : DROP drop ;
( 6.1.1290 DUP       )        : DUP dup ;
( 6.1.1310 ELSE      )        : ELSE ['] then execute ['] DUP compile 0 literal, ['] =if execute ['] DROP compile ; IMMEDIATE
( 6.1.1320 EMIT      )        : EMIT emit ;
( 6.1.1345 ENVIRONMENT? )     : ENVIRONMENT? 2drop 0 ;
( 6.1.1360 EVALUATE  )        ( --- )
( 6.1.1370 EXECUTE   )        : EXECUTE push ;
( 6.1.1380 EXIT      )        : EXIT 9 , ; IMMEDIATE
                              create dst 0 ,
                              create val 0 ,
                              : (fill) for val @ dst @ ! 1 dst +! next ;
( 6.1.1540 FILL      )        : FILL swap push val ! dst ! pop (fill) ;
( 6.1.1550 FIND      )        ( --- )
                              stub: FIND
( 6.1.1561 FM/MOD    )        ( --- )
                              stub: FM/MOD
( 6.1.1650 HERE      )        : HERE here ;
( 6.1.1670 HOLD      )        : HOLD 1 hld +! holdaddr hld @ - ! ;
( 6.1.1680 I         )        ( --- )
                              stub: I
( 6.1.1700 IF        )        : IF ['] DUP compile 0 literal, ['] !if execute ['] drop compile ; IMMEDIATE
( 6.1.1720 INVERT   )         : INVERT not ;
( 6.1.1730 J        )         ( --- )
                              stub: J
( 6.1.1750 KEY      )         : KEY key ;
( 6.1.1760 LEAVE    )         ( --- )
                              stub: LEAVE
( 6.1.1780 LITERAL  )         : LITERAL literal, ;
( 6.1.1800 LOOP     )         ( --- )
                              stub: LOOP
( 6.1.1805 LSHIFT   )         : LSHIFT << ;
( 6.1.1810 M*       )         : M* * ;
( 6.1.1870 MAX      )         : MAX 2dup >if drop ;; then nip ;
( 6.1.1880 MIN      )         : MIN 2dup >if drop ;; then nip ;
( 6.1.1890 MOD      )         : MOD mod ;
                              create src 0 ,
                              create dst 0 ,
                              : (copy) for src @ @ dst @ ! 1 src +! 1 dst +! next ;
( 6.1.1900 MOVE     )         : MOVE push dst ! src ! pop (copy) ;
( 6.1.1910 NEGATE   )         : NEGATE neg ;
( 6.1.1980 OR       )         : OR or ;
( 6.1.1990 OVER     )         : OVER over ;
                              : (to-entry) last repeat @ 0; 2dup d->xt @ =if nip ;; then again ;
                              : >entry (to-entry) drop ;
                              : ?immediate d->class @ dup ['] .macro =if -1 drop ;; then 1 =if -1 ;; then 0 ;
( 6.1.2033 POSTPONE )         : POSTPONE ' dup literal, >entry ?immediate -1 =if ['] execute compile ;; then ['] compile compile ; IMMEDIATE
( 6.1.2050 QUIT     )         : QUIT 0 execute ;
( 6.1.2060 R>       )         : R> 6 , ; IMMEDIATE
( 6.1.2070 R@       )         : R@ pop pop dup swap push swap push ;
( 6.1.2120 RECURSE  )         : RECURSE 7 , last @ d->xt @ , ; IMMEDIATE
( 6.1.2140 REPEAT   )         : REPEAT ` again ; IMMEDIATE
( 6.1.2160 ROT      )         : ROT rot ;
( 6.1.2162 RSHIFT   )         : RSHIFT >> ;
( 6.1.2165 S"       )         : S" ['] s" execute ['] dup compile ['] getLength compile ; IMMEDIATE
( 6.1.2170 S>D      )         ( --- )
                              stub: S>D
( 6.1.2210 SIGN     )         : SIGN 0 <if 45 HOLD then ;
( 6.1.2214 SM/REM   )         ( --- )
                              stub: SM/REM
( 6.1.2216 SOURCE   )         ( --- )
                              stub: SOURCE
( 6.1.2220 SPACE    )         : SPACE BL emit ;
( 6.1.2230 SPACES   )         : SPACES repeat 0; SPACE 1- again ;
( 6.1.2250 STATE    )         : STATE compiler ;
( 6.1.2260 SWAP     )         : SWAP swap ;
( 6.1.2270 THEN     )         : THEN ['] then execute ['] drop compile ; IMMEDIATE
( 6.1.2310 TYPE     )         : TYPE for dup @ . 1+ next drop ;
( 6.1.2320 U.       )         ( --- )
                              stub: U.
( 6.1.2340 U<       )         ( --- )
                              stub: U<
( 6.1.2360 UM*      )         ( --- )
                              stub: UM*
( 6.1.2370 UM/MOD   )         ( --- )
                              stub: UM/MOD
( 6.1.2380 UNLOOP   )         ( --- )
                              stub: UNLOOP
( 6.1.2390 UNTIL    )         ( --- )
                              stub: UNTIL
( 6.1.2410 VARIABLE )         : VARIABLE create 0 , ;
( 6.1.2430 WHILE    )         : WHILE -1 !if pop drop then ;
( 6.1.2450 WORD     )         ( --- )
                              stub: WORD
( 6.1.2490 XOR      )         : XOR xor ;
( 6.1.2500 [        )         ( Supported by RETRO )
( 6.1.2510 [']      )         ( Supported by RETRO )
( 6.1.2520 [CHAR]   )         : [CHAR] CHAR literal, ; IMMEDIATE
( 6.1.2540 ]        )         ( Supported by RETRO )


( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( 6.2 CORE EXT                                              )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( 6.2.0060 #TIB          )  stub: #TIB
( 6.2.0200 .(            )  stub: .(
( 6.2.0210 .R            )  stub: .R
( 6.2.0260 0<>           )  : 0<> 0 !if TRUE ;then FALSE ;
( 6.2.0280 0>            )  : 0> 0 >if TRUE ;then FALSE ;
( 6.2.0340 2>R           )  stub: 2>R
( 6.2.0410 2R>           )  stub: 2R>
( 6.2.0415 2R@           )  stub: 2R@
( 6.2.0455 :NONAME       )  : :NONAME here ] ;
( 6.2.0500 <>            )  : <> !if TRUE ;then FALSE ;
( 6.2.0620 ?DO           )  stub: ?DO
( 6.2.0700 AGAIN         )  stub: AGAIN
( 6.2.0855 C"            )  stub: C"
( 6.2.0873 CASE          )  stub: CASE
( 6.2.0945 COMPILE,      )  stub: COMPILE,
( 6.2.0970 CONVERT       )  stub: CONVERT
( 6.2.1342 ENDCASE       )  stub: ENDCASE
( 6.2.1343 ENDOF         )  stub: ENDOF
( 6.2.1350 ERASE         )  : ERASE 0 swap fill ;
( 6.2.1390 EXPECT        )  stub: EXPECT
( 6.2.1485 FALSE         )  ( Supported by Retro )
( 6.2.1660 HEX           )  stub: HEX
( 6.2.1850 MARKER        )  stub: MARKER
( 6.2.1930 NIP           )  : NIP nip ;
( 6.2.1950 OF            )  stub: OF
( 6.2.2000 PAD           )  : PAD here 1024 + ;
( 6.2.2008 PARSE         )  stub: PARSE
( 6.2.2030 PICK          )  {{
                               variable a
                               : 0? a @ 0 =if pop drop dup then ;
                            ---reveal---
                               : PICK
                                 a ! 0?
                                 a @ for pop swap push push next
                                 dup
                                 a @ for pop pop swap push swap next
                               ;
                            }}
( 6.2.2040 QUERY         )  stub: QUERY
( 6.2.2125 REFILL        )  : REFILL FALSE ;
( 6.2.2148 RESTORE-INPUT )  stub: RESTORE-INPUT
( 6.2.2150 ROLL          )  stub: ROLL
( 6.2.2182 SAVE-INPUT    )  stub: SAVE-INPUT
( 6.2.2218 SOURCE-ID     )  stub: SOURCE-ID
( 6.2.2240 SPAN          )  stub: SPAN
( 6.2.2290 TIB           )  stub: TIB
( 6.2.2295 TO            )  : TO ' compiler @ -1 =if literal, ` ! ;then ! ; IMMEDIATE
( 6.2.2298 TRUE          )  ( Supported by Retro )
( 6.2.2300 TUCK          )  : TUCK tuck ;
( 6.2.2330 U.R           )  stub: U.R
( 6.2.2350 U>            )  stub: U>
( 6.2.2395 UNUSED        )  : UNUSED #mem @ here - ;
( 6.2.2405 VALUE         )  : .value compiler @ -1 =if literal, ` @ ;then @ ;
                            : VALUE create ['] .value last @ d->class ! 0 , ;
( 6.2.2440 WITHIN        )  stub: WITHIN
( 6.2.2530 [COMPILE]     )  stub: [COMPILE]
( 6.2.2535 \             )  : \ whitespace off 10 accept whitespace on ; IMMEDIATE
